<!DOCTYPE html>
<html lang="en">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Simple Traffic Model Simulator</title>
  <style>
    :root { 
      --bg:#0e0f12; 
      --panel:#14161b; 
      --muted:#828aa0; 
      --text:#e8ebf2; 
      --accent:#6ee7ff; 
      --accent2:#a78bfa; 
      --good:#86efac; 
      --warn:#fbbf24; 
      --danger:#fb7185; 
      --grid-gap:14px; 
      --radius:14px; 
      --card-w:560px; 
      --w-polar:660px; 
      --h-polar:360px; 
      --w-omega:660px; 
      --h-omega:300px; 
      --w-omega1:660px; 
      --h-omega1:300px; 
      --w-delta:660px; 
      --h-delta:300px; 
      --w-time:660px; 
      --h-time:300px; 
    }
    *{box-sizing:border-box} html,body{height:100%} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji;color:var(--text);background:radial-gradient(1200px 800px at 40% -200px,#1b1f2b 0%,var(--bg) 60%)}
    .shell{display:grid;grid-template-columns:1fr;grid-template-rows:auto auto auto 1fr auto;gap:var(--grid-gap);min-height:100vh;padding:16px 16px 20px}
    header,footer{grid-column:1/-1;background:linear-gradient(180deg,#171923 0%,#11131a 100%);border:1px solid #222633;border-radius:var(--radius);padding:10px 14px;display:flex;align-items:center;justify-content:space-between;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    header h1{font-size:18px;margin:0;font-weight:600;letter-spacing:.2px} header .sub{color:var(--muted);font-size:12px}
    .left,.top,.eqpane{background:var(--panel);border:1px solid #222633;border-radius:var(--radius);box-shadow:0 0px 0px rgba(0,0,0,.25);padding:12px}
    .eqpane .eq{ display:flex; justify-content:left; margin:0px 0 0; }
    .left{display:grid;grid-template-rows:auto auto 1fr;gap:var(--grid-gap)} .canvasWrap{display:flex;flex-wrap:wrap;gap:10px;align-items:flex-start}
    .card{background:#10131a;border:1px solid #1e2330;border-radius:12px;padding:8px}
    .canvasWrap .card{position:relative;cursor:grab;width:var(--card-w);max-width:var(--card-w);flex:0 0 var(--card-w)} .canvasWrap .card.dragging{cursor:grabbing} .card.dragging{opacity:.65;outline:2px dashed #3b82f6}
    .card[data-id="polar"]{--card-w:var(--w-polar);height:var(--h-polar)} 
    .card[data-id="omega"]{--card-w:var(--w-omega);height:var(--h-omega)} 
    .card[data-id="omega1"]{--card-w:var(--w-omega1);height:var(--h-omega1)} 
    .card[data-id="delta"]{--card-w:var(--w-delta);height:var(--h-delta)} 
    .card[data-id="time"]{--card-w:var(--w-time);height:var(--h-time)}
    .resizable{min-width:280px;min-height:180px} .resizer{position:absolute;right:6px;bottom:6px;width:14px;height:14px;cursor:se-resize;border-radius:4px;border:1px solid #3a4359;background:linear-gradient(135deg,rgba(255,255,255,.18) 0 40%,rgba(255,255,255,0) 40%);box-shadow:inset 0 0 0 1px rgba(0,0,0,.25)}
    .card[data-id="polar"] .cardTitle{font-weight:400;text-align:center}
    canvas{width:100%;height:auto;display:block;background:#0c0f15;border-radius:10px}
    .top{display:grid;grid-template-rows:auto;gap:var(--grid-gap);margin-bottom:-10px}
    .controls{display:grid;gap:8px} .grid2{display:grid;grid-template-columns:max-content max-content;column-gap:16px;row-gap:8px;justify-content:start;align-items:start;margin-bottom: 20px}
    .group{background:#0f1218;border:1px solid #222633;border-radius:10px;padding:10px}
    .group h3{margin:0 0 8px;font-size:12px;font-weight:700;color:var(--muted);letter-spacing:.5px;text-transform:uppercase}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:4px}
    input[type=number],select{width:100%;background:#0b0e13;color:var(--text);border:1px solid #232837;border-radius:8px;padding:8px 10px;outline:none}
    /* Make only the Preset dropdown narrower */
    #selPreset{
      width: 240px;
      max-width: 240px;
      flex: 0 0 auto;
    }
    .top .group input[type=number]{width:100px}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap}
    button{background:linear-gradient(180deg,#1c2633 0%,#141b24 100%);color:var(--text);border:1px solid #253042;border-radius:10px;padding:10px 12px;font-weight:600;font-size:13px;cursor:pointer;transition:transform .06s ease,filter .12s ease,background .12s ease}
    button:hover{filter:brightness(1.05)} button:active{transform:translateY(1px)} .primary{border-color:#3b82f6;background:linear-gradient(180deg,#1f2e47 0%,#152135 100%)} .danger{border-color:#be123c;background:linear-gradient(180deg,#3a1923 0%,#2a1017 100%)} .muted{background:#0d1117;border-color:#1f2431}
    footer{font-size:12px;color:var(--muted)} a{color:var(--accent);text-decoration:none} a:hover{text-decoration:underline}
    @media (max-width:1100px){.shell{grid-template-columns:1fr}}
      /* Math styling for inline labels */
    .math{ font-family: "STIX Two Math","Cambria Math","Times New Roman",serif; font-style: italic; }
    .math sub{ font-size:.75em; line-height:0; vertical-align:-0.25em; }
    .math sup{ font-size:.75em; line-height:0; vertical-align:0.45em; }
    header .eq{ margin-top:8px; }
    /* --- Hover info blurb (3s delayed) --- */
    .card .hoverBlurb{
      position:absolute;
      top:8px; left:8px;
      max-width:72%;
      background:rgba(20,24,33,0.95);
      color:var(--text);
      border:1px solid #2b3245;
      border-radius:8px;
      padding:8px 10px;
      font-size:12px;
      line-height:1.3;
      box-shadow:0 6px 16px rgba(0,0,0,.35);
      opacity:0;
      transform:translateY(-4px);
      pointer-events:none;
      z-index:10;
      transition:opacity .18s ease, transform .18s ease;
    }
    .card .hoverBlurb.show{ opacity:1; transform:translateY(0); }
    /* --- Inline "(i)" info icon + tooltip --- */
    .infoIcon{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:16px; height:16px;
      margin-left:6px;
      border-radius:50%;
      background:#1f2633;
      border:1px solid #2b3245;
      color:var(--accent);
      font-weight:700;
      font-size:11px;
      line-height:1;
      cursor:help;
      position:relative;
      vertical-align:middle;
      user-select:none;
    }
    
    .infoIcon::after{
      content: attr(data-tip);
      position:absolute;
      left:50%;
      bottom:125%;
      transform: translate(-50%,-6px);
      background: rgba(20,24,33,0.98);
      color: var(--text);
      border:1px solid #2b3245;
      border-radius:8px;
      padding:8px 10px;
      font-size:12px;
      line-height:1.35;
      min-width:180px;
      max-width:280px;
      white-space:normal;
      box-shadow:0 6px 16px rgba(0,0,0,.35);
      opacity:0;
      pointer-events:none;
      z-index:50;
      transition: opacity .15s ease, transform .15s ease;
    }
    
    .infoIcon::before{
      content:"";
      position:absolute;
      left:50%;
      bottom:118%;
      transform: translateX(-50%);
      border:6px solid transparent;
      border-top-color: rgba(20,24,33,0.98);
      opacity:0;
      transition: opacity .15s ease;
    }
    
    .infoIcon:hover::after,
    .infoIcon[data-open="1"]::after{
      opacity:1;
      transform: translate(-50%,-10px);
    }
    .infoIcon:hover::before,
    .infoIcon[data-open="1"]::before{
      opacity:1;
    }
  </style>
  <script>
window.MathJax = {
  options: {
    processHtmlClass: 'mathjax',
    ignoreHtmlClass: 'tex2jax_ignore'
  },
  tex: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\\[','\\]']],
    tags: 'none'
  },
  svg: { fontCache: 'global' }
};
  </script>
  
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
</head>
<body>
  <div class="shell">
    <header>
      <div>
        <h1>Agent-Based Traffic Simulator</h1>
        <div class="sub">Simulation of multiple agents interacting via the dynamical equations discussed <a href=XXX>here</a>, and shown below for reference.</div>
        <div class="sub">Use the presets to select parameter sets that demonstrate distinct qualitative behaviour, or explore the parameter space on your own. </div>
        <div class="sub">Tristan Ursell, PhD © 2025 </div>
      </div>
    </header>
    <section class="eqpane">
    <div class="eq mathjax">
      \begin{equation}
      \ddot{\theta}_i(t) =
      \begin{cases}
      -\alpha \dot{\theta}_i(t), & \Delta_i(t) < \frac{d_0}{R} \\
      \alpha \left( 1 - e^{-(R\Delta_i(t) - d_0)} - \dot{\theta}_i(t) \right), & \Delta_i(t) \ge \frac{d_0}{R}
      \end{cases}
        \,\,\,\,\,\,\mbox{with}\,\,\,\,\,\,\Delta_i = \theta_{i+1} - \theta_i
      \end{equation}
  </div>
</section>
    
    <section class="top">
      <div class="controls">
        <div class="group">
          <!-- Preset selector -->
          <div style="margin-bottom:8px;display:flex;gap:8px;align-items:center;">
            <label for="selPreset" style="margin:0;">Preset:</label>
            <select id="selPreset">
              <option value="">Custom (no preset)</option>
              <option value="small_gaussian">1. Small, fast, low-density soliton (after coarsening)</option>
              <option value="quasistable">2. Quasi-stable, high-density soliton</option>
              <option value="two_stable_soliton">3. Two high-density solitons</option>
              <option value="stable_high_freq">4. Stable high freq. perturbation</option>
              <option value="return_to_stability2">5. Ringing back to steady-state</option>
              <option value="three_quasi">6. Low freq. perturb to steady-state</option>
              <option value="slow_onset">7. Slow phase separation</option>
              <option value="sticky_d_zone1">8. Slow phase separation (higher k)</option>
              <option value="kvec_settle">9. High freq. k perturb</option>
              <option value="should_stop1">10. Jammed in SS, two stable solitons</option>
              <option value="should_stop2">11. Jammed in SS, unstable solitons</option>
              <option value="low_lh_diff">12. Two-phase w/ similar densities</option>
              <option value="sticky_stable_low_perturb">13. High alpha &amp; N, low perturbation</option>
              <option value="sticky_stable_high_perturb">14. High alpha &amp; N, high perturb solitons</option>         
              <option value="large_tight">15. Large N, stable jamiton</option> 
              <option value="large_similar_density">16. Large N, similar densities</option> 
              <option value="peters_out">17. Peters out</option>
              <option value="small_num">18. Small N waves</option>
            </select>
          </div>
          <div class="grid2">
            <div style="display:grid;gap:8px;">
              <div><label>α/α<sub>c</sub>     <span class="infoIcon" aria-label="info" data-tip="Sets α as a fraction of the critical α_c for linear stability. Values &gt; 1 tend toward the steady-state, values &lt; 1 propagate disturbances in density, and frequently phase separate.">i</span></label><input id="inpAlphaRatio" type="number" value="0.5" step="0.01" min="0"></div>
              <div><label for="inpN">N (cars)    <span class="infoIcon" aria-label="info" data-tip="Number of agents on the ring. Higher N reduces uniform spacing Δ* = 2π/N.">i</span></label><input id="inpN" type="number" value="50" min="3" max="500" step="1"></div>
              <div><label for="inpR">R (ring radius)   <span class="infoIcon" aria-label="info" data-tip="Ring radius. For the same angular gap Δᵢ, the physical gap is R·Δᵢ. Larger R increases spacing RΔᵢ for fixed N.">i</span></label><input id="inpR" type="number" value="5" step="0.1"></div>
              <div><label for="inpd0">d₀ (stop distance)  <span class="infoIcon" aria-label="info" data-tip="Minimum gap where agents brake: if R·Δᵢ ≤ d₀, speed exponentially decreases with rate α toward zero (stop regime).">i</span></label><input id="inpd0" type="number" value="0.5" step="0.01"></div>
            </div>
            <div style="display:grid;gap:8px;">
              <div><label for="inpEps">ε (angle perturbation) <span class="infoIcon" aria-label="info" data-tip="Initial sinusoidal amplitude (radians) of θᵢ; seeds pattern formation. Larger ε = stronger initial disturbance. The maximum ε is set by mean separation and perturbation frequency.">i</span></label><input id="inpEps" type="number" value="0.5" step="0.01"></div>
              <div><label for="inpNfreq">n (perturb freq)  <span class="infoIcon" aria-label="info" data-tip="Spatial frequency of the initial perturbation (cycles per 2π); can be fractional.">i</span></label><input id="inpNfreq" type="number" value="0.5" step="0.01"></div>
              <div><label for="inpSteps">Steps / frame  <span class="infoIcon" aria-label="info" data-tip="How many Δt updates to run per animation frame. Higher = faster simulation time, heavier on CPU.">i</span></label><input id="inpSteps" type="number" value="500" step="1"></div>
              <!-- NEW: Time Window parameter -->
              <div><label for="inpTimeWindow">Time Window <span class="infoIcon" aria-label="info" data-tip="Width of the time window (in 1/Ω_max units) shown in the ω₁(t) plot.">i</span></label><input id="inpTimeWindow" type="number" value="100" step="1" min="1"></div>
            </div>
          </div>
          <!-- Actions (moved inside parameter group) -->
          <div class="actions" style="margin-top:10px;display:flex;gap:16px;align-items:flex-start;flex-wrap:wrap;">
            <div class="btnRow" style="display:flex;gap:12px;">
              <button id="btnStart" class="primary" title="Run the simulation loop. Continues until Stop or Reset.">Start</button>
              <button id="btnStop" class="muted" title="Pause the simulation without changing the current state.">Stop</button>
              <button id="btnStep" class="muted" title="Advance one frame.">Step</button>
              <button id="btnReset" class="danger" title="Apply current parameters and reset the simulation to initial conditions.">Reset</button>
              <!-- Share current settings as a URL -->
              <button id="btnShare" class="muted" title="Copy a URL that restores these settings">Get shareable link</button>
            </div>
            
            <div style="display:flex;flex-direction:column;gap:6px;min-width:max-content;">
              <label style="display: inline-flex; align-items: center; gap: 8px; opacity: 1; cursor: pointer;" title="">
                <input type="checkbox" id="chkShowRef" checked> show θᵢ(t) − Ωₑᵩt ring
              </label>
              <label style="display:inline-flex;align-items:center;gap:8px;">
                <input type="checkbox" id="chkPhase" checked> show two-phase classification
              </label>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="left">
      <div class="canvasWrap" id="canvasWrap">
        <div class="card draggable resizable" data-id="polar" draggable="true" data-blurb="Left ring shows θᵢ(t) for all agents, each represented by a colored dot. As the system phase separates into high and low density, the green dot tracks the high-density phase (mean angle), the red and green circular pieces track the location of each phase, and the gray dot is the theoretical prediction for jamiton velocity. Right ring shows θᵢ(t) − Ω_eq·t when enabled, this shows motion relative to the steady-state.">
          <div class="cardTitle"><span id="titlePolar">T (Ω<sub>max</sub><sup>-1</sup>) = 0.0</span></div>
          <canvas id="canvasMain" width="642" height="308" style="height: 308px; width: 642px;"></canvas>
          <div class="resizer" title="Drag to resize"></div>
        </div>
        <div class="card draggable resizable" data-id="omega" draggable="true" data-blurb="Per-agent angular speed ωᵢ/Ωₘₐₓ vs agent index. Gray line=1, dashed = Ω_eq, blue dashed = steady-state ω from max Δᵢ.">
          <canvas id="canvasOmega" width="642" height="282" style="height: 282px; width: 642px;"></canvas>
          <div class="resizer" title="Drag to resize"></div>
        </div>
        <!-- Agent #1 angular speed vs time (moving window) -->
        <div class="card draggable resizable" data-id="omega1" draggable="true" data-blurb="Angular speed ω₁/Ωₘₐₓ of Agent #1 vs time, shown over the most recent Time Window.">
          <canvas id="canvasOmega1" width="642" height="282" style="height: 282px; width: 642px;"></canvas>
          <div class="resizer" title="Drag to resize"></div>
        </div>
        <div class="card draggable resizable" data-id="delta" draggable="true" data-blurb="Neighbor spacing Δᵢ (rad). Dashed refs: 0 (white), 2π/N (gray), d₀/R (orange). Crash overlay triggers on overtake.">
          <canvas id="canvasDelta" width="642" height="282" style="height: 282px; width: 642px;"></canvas>
          <div class="resizer" title="Drag to resize"></div>
        </div>
        <div class="card draggable resizable" data-id="time" draggable="true" data-blurb="RMS(ω−Ω_eq) (left axis) and ⟨J⟩ (right axis) over time. Right dashed line = steady-state ⟨J⟩.">
          <canvas id="canvasTime" width="642" height="282" style="height: 282px; width: 642px; display: block;"></canvas>
          <div class="resizer" title="Drag to resize"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // ================================
    // Constants, DOM, light utilities
    // ================================
    const TWO_PI = Math.PI*2;
    const AXIS_COLOR = "#cfd3dc", AXIS_W = 3, DASH_W = 2, FONT_PX = 16;
    const DOT_SCALE = 1.3;
    const EPS_CRASH = 1e-6;
    const DT = 0.0001;
    
    const main = document.getElementById('canvasMain'), ctxMain = main.getContext('2d');
    const cnvOmega = document.getElementById('canvasOmega'), ctxOmega = cnvOmega.getContext('2d');
    const cnvOmega1 = document.getElementById('canvasOmega1'), ctxOmega1 = cnvOmega1.getContext('2d');
    const cnvDelta = document.getElementById('canvasDelta'), ctxDelta = cnvDelta.getContext('2d');
    const cnvTime  = document.getElementById('canvasTime'),  ctxTime  = cnvTime.getContext('2d');
    const wrap = document.getElementById('canvasWrap');
    const titlePolar = document.getElementById('titlePolar');

    const inpN = document.getElementById('inpN'),
          inpR = document.getElementById('inpR'),
          inpd0 = document.getElementById('inpd0');
    const inpEps = document.getElementById('inpEps'),
          inpNfreq = document.getElementById('inpNfreq');
    const inpSteps = document.getElementById('inpSteps'),
          inpAlphaRatio = document.getElementById('inpAlphaRatio');
    const inpTimeWindow = document.getElementById('inpTimeWindow'); // NEW

    const btnStart = document.getElementById('btnStart'),
      btnStop  = document.getElementById('btnStop'),
      btnStep  = document.getElementById('btnStep'),
      btnReset = document.getElementById('btnReset'),
      btnShare = document.getElementById('btnShare');
    const chkShowRef = document.getElementById('chkShowRef');
    const chkPhase = document.getElementById('chkPhase');
    const showRefRing = () => state.OmegaEq > 0 && (!chkShowRef || chkShowRef.checked);
    const showPhase  = () => (!chkPhase   || chkPhase.checked);
    let rafId = null;

    // ===== URL share helpers =====
    function buildShareQuery() {
      const q = new URLSearchParams();
      q.set('N', inpN.value);
      q.set('R', inpR.value);
      q.set('d0', inpd0.value);
      q.set('eps', inpEps.value);
      q.set('nf', inpNfreq.value);
      q.set('spf', inpSteps.value);
      q.set('ar', inpAlphaRatio.value);
      if (inpTimeWindow) q.set('tw', inpTimeWindow.value); // include time window
      if (chkShowRef) q.set('ref', chkShowRef.checked ? '1' : '0');
      if (chkPhase)   q.set('phase', chkPhase.checked ? '1' : '0');
      if (selPreset && selPreset.value) q.set('preset', selPreset.value);
      return q.toString();
    }
    
    function applyFromQuery(qs) {
      const p = new URLSearchParams(qs.startsWith('?') ? qs.slice(1) : qs);
      if (p.has('preset') && !p.has('N') && !p.has('R') && !p.has('d0')) {
        const key = p.get('preset');
        if (PRESETS[key]) {
          applySelectedPreset(key);
          return true;
        }
      }
      if (p.has('N'))   inpN.value        = p.get('N');
      if (p.has('R'))   inpR.value        = p.get('R');
      if (p.has('d0'))  inpd0.value       = p.get('d0');
      if (p.has('eps')) inpEps.value      = p.get('eps');
      if (p.has('nf'))  inpNfreq.value    = p.get('nf');
      if (p.has('spf')) inpSteps.value    = p.get('spf');
      if (p.has('ar'))  inpAlphaRatio.value = p.get('ar');
      if (p.has('tw') && inpTimeWindow) inpTimeWindow.value = p.get('tw'); // NEW
      if (p.has('ref') && chkShowRef) chkShowRef.checked = p.get('ref') === '1';
      if (p.has('phase') && chkPhase) chkPhase.checked   = p.get('phase') === '1';
      if (selPreset) selPreset.value = p.get('preset') || '';
      hardReset({ apply: true });
      return true;
    }

    // ===== Preset parameter selector =====
    const selPreset = document.getElementById('selPreset');

    const PRESETS = {
      small_gaussian:     { N:52,  R:5,   d0:0.6,  epsilon:0.2, nfreq:4, stepsPerFrame:500, alphaRatio:0.8 },
      quasistable:     { N:50, R:5,   d0:0.5, epsilon:0.5,nfreq:0.5, stepsPerFrame:500, alphaRatio:1 },
      two_stable_soliton:  { N:30,  R:6,   d0:0.5,  epsilon:0.05, nfreq:2, stepsPerFrame:500, alphaRatio:0.75 },
      stable_high_freq:   { N:50, R:5,   d0:0.6,  epsilon:0.1 ,nfreq:10, stepsPerFrame:500, alphaRatio:0.4 },
      return_to_stability2: { N:50,  R:5,   d0:0.2,  epsilon:0.2, nfreq:5, stepsPerFrame:500, alphaRatio:1.05 },
      three_quasi: { N:50,  R:5,   d0:0.2,  epsilon:0.2, nfreq:1, stepsPerFrame:500, alphaRatio:2 },
      slow_onset: { N:50,  R:5,   d0:0.2,  epsilon:0.2, nfreq:1, stepsPerFrame:500, alphaRatio:0.99 },
      sticky_d_zone1: { N:50,  R:10,   d0:0.5,  epsilon:0.05, nfreq:2, stepsPerFrame:500, alphaRatio:0.98 },
      kvec_settle: { N:50,  R:5,   d0:0.6,  epsilon:0.05, nfreq:15, stepsPerFrame:500, alphaRatio:0.4 },
      should_stop1: { N:50,  R:5,   d0:0.8,  epsilon:0.5, nfreq:2, stepsPerFrame:500, alphaRatio: 0.25 },
      should_stop2: { N:50,  R:5,   d0:0.8,  epsilon:0.25, nfreq:2, stepsPerFrame:500, alphaRatio: 0.25 },
      low_lh_diff: { N:50,  R:50,   d0:6,  epsilon:0.2, nfreq:2, stepsPerFrame:50, alphaRatio: 0.8 },
      sticky_stable_low_perturb: { N:200,  R:50,   d0:0.5,  epsilon:0.9, nfreq:0.5, stepsPerFrame:500, alphaRatio: 1.1 },
      sticky_stable_high_perturb: { N:200,  R:50,   d0:0.5,  epsilon:1, nfreq:0.5, stepsPerFrame:500, alphaRatio: 1.1 },
      large_tight: { N:500,  R:50,   d0:0.8,  epsilon:1, nfreq:0.5, stepsPerFrame:500, alphaRatio: 0.3 },
      large_similar_density: { N:500,  R:50,   d0:0.5,  epsilon:1, nfreq:0.5, stepsPerFrame:500, alphaRatio: 1 },
      peters_out: { N:50,  R:5,   d0:0.65,  epsilon:1, nfreq:1, stepsPerFrame:500, alphaRatio: 0.63 },
      small_num: { N:5,  R:5,   d0:5,  epsilon:0.5, nfreq:0.5, stepsPerFrame:500, alphaRatio: 0.65 }
    };

    function setInputsFromPreset(p) {
      if (!p) return;
      inpN.value = p.N;
      inpR.value = p.R;
      inpd0.value = p.d0;
      inpEps.value = p.epsilon;
      inpNfreq.value = p.nfreq;
      inpSteps.value = p.stepsPerFrame;
      inpAlphaRatio.value = p.alphaRatio;
      // Time window left as user-controlled; not overridden by presets
    }

    function applySelectedPreset(key) {
      const p = PRESETS[key];
      if (!p) return;
      setInputsFromPreset(p);
      hardReset({ apply: true });
    }

    selPreset && selPreset.addEventListener('change', () => {
      const key = selPreset.value;
      if (key) applySelectedPreset(key);
    });

    const numericInputs = [inpN, inpR, inpd0, inpEps, inpNfreq, inpSteps, inpAlphaRatio, inpTimeWindow];
    numericInputs.forEach(el => el && el.addEventListener('input', () => { if (selPreset) selPreset.value = ''; }));

    function syncRefCheckbox(){
      if (!chkShowRef) return;
      const allow = state.OmegaEq > 0;
      chkShowRef.disabled = !allow;
      chkShowRef.checked  = allow ? true : false;
      const lbl = chkShowRef.closest('label');
      if (lbl) {
        lbl.style.opacity = allow ? 1 : 0.5;
        lbl.style.cursor  = allow ? 'pointer' : 'not-allowed';
        lbl.title = allow ? '' : 'Disabled when Ω_eq ≤ 0';
      }
    }

    // Canvas helpers
    function prepCanvas(canvas, ctx){
      const dpr = window.devicePixelRatio||1;
      const w = Math.max(1, Math.floor(canvas.clientWidth||canvas.width/dpr));
      const h = Math.max(1, Math.floor(canvas.clientHeight||canvas.height/dpr));
      const need = canvas.width!==Math.floor(w*dpr) || canvas.height!==Math.floor(h*dpr);
      if(need){ canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr); }
      ctx.setTransform(dpr,0,0,dpr,0,0); ctx.clearRect(0,0,w,h);
      return {W:w,H:h};
    }

    function parseMathRuns(str){
      const r=[]; 
      for(let i=0;i<str.length;){
        const c=str[i];
        if(c==='_'||c==='^'){
          const k=c; i++; let t="";
          if(str[i]==='{'){
            i++; const j=str.indexOf('}',i);
            t=(j>-1?str.slice(i,j):str.slice(i));
            i=(j>-1?j+1:str.length);
          } else {
            t=str[i]||""; i++;
          }
          r.push({text:t,kind:k==='_'?'sub':'sup'});
        } else {
          let j=i; while(j<str.length && str[j]!== '_' && str[j]!== '^') j++;
          r.push({text:str.slice(i,j),kind:'norm'}); i=j;
        }
      } 
      return r;
    }

    function drawMathText(ctx,str,x,y,{size=12,align='left',color='#9aa3b7',family='system-ui, -apple-system, Segoe UI, Roboto'}={}){
      const runs=parseMathRuns(str), subS=.75, supS=.75, subY=size*.25, supY=size*.5, fontPx=p=>`${p}px ${family}`; 
      let w=0;
      for(const rr of runs){ const s=rr.kind==='norm'?size:(rr.kind==='sub'?size*subS:size*supS); ctx.font=fontPx(s); w+=ctx.measureText(rr.text).width; }
      let cx=x; if(align==='center') cx-=w/2; else if(align==='right') cx-=w; ctx.fillStyle=color;
      for(const rr of runs){ 
        const s=rr.kind==='norm'?size:(rr.kind==='sub'?size*subS:size*supS); 
        const dy=rr.kind==='norm'?0:(rr.kind==='sub'?subY:-supY); 
        ctx.font=fontPx(s); 
        ctx.fillText(rr.text,cx,y+dy); 
        cx+=ctx.measureText(rr.text).width; 
      }
    }

    function syncCanvasSizes(){ 
      document.querySelectorAll('.canvasWrap .card').forEach(card=>{
        const c=card.querySelector('canvas'); if(!c) return;
        const cs=getComputedStyle(card);
        const padV=(+parseFloat(cs.paddingTop)||0)+(+parseFloat(cs.paddingBottom)||0);
        const padH=(+parseFloat(cs.paddingLeft)||0)+(+parseFloat(cs.paddingRight)||0);
        const title=card.querySelector('.cardTitle'); const titleH=title?(title.offsetHeight+6):0;
        c.style.height=Math.max(120,card.clientHeight-padV-titleH)+'px';
        c.style.width=Math.max(200,card.clientWidth-padH)+'px';
      }); 
    }

    const clamp=(x,a,b)=> Math.max(a,Math.min(b,x));
    function hsvToRgb(h,s,v){ const f=(n,k=(n+h*6)%6)=>v-v*s*Math.max(Math.min(k,4-k,1),0); return [f(5),f(3),f(1)]; }
    function colormapHSV(N){ const arr=[]; for(let k=0;k<N;k++){ const h=k/N,[r,g,b]=hsvToRgb(h,.9,.95); arr.push(`rgb(${Math.round(r*255)},${Math.round(g*255)},${Math.round(b*255)})`);} return arr; }
    function complexMeanAngles(theta){ let re=0,im=0; for(const th of theta){ re+=Math.cos(th); im+=Math.sin(th);} re/=theta.length; im/=theta.length; return {r:Math.hypot(re,im),phi:Math.atan2(im,re)}; }
    const wrapAngle=a=>{ a%=TWO_PI; return a<0?a+TWO_PI:a; };
    function niceTicks(min,max,count=5){
      if(!isFinite(min)||!isFinite(max)||min===max) return [min||0];
      const span=max-min,step0=span/Math.max(1,count),p10=10**Math.floor(Math.log10(step0)),err=step0/p10;
      const m= err>=7.5?10: err>=3.5?5: err>=1.5?2:1;
      const step=m*p10,nmin=Math.floor(min/step)*step,nmax=Math.ceil(max/step)*step,t=[];
      for(let v=nmin; v<=nmax+1e-12; v+=step) t.push(+v.toFixed(10)); return t;
    }
    function drawLeftTicks(ctx,L,T,B,vals,mapY,color=AXIS_COLOR){
      ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=1.5;
      for(const v of vals){ const y=mapY(v); if(y<T-1||y>B+1) continue;
        ctx.beginPath(); ctx.moveTo(L-6,y); ctx.lineTo(L,y); ctx.stroke();
        drawMathText(ctx,String(+v.toFixed(2)).replace(/\.00$/,""),L-8,y+4,{size:12,align:'right',color});
      } ctx.restore();
    }
    function drawRightTicks(ctx,R,T,B,vals,mapY,color=AXIS_COLOR){
      ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=1.5;
      for(const v of vals){ const y=mapY(v); if(y<T-1||y>B+1) continue;
        ctx.beginPath(); ctx.moveTo(R,y); ctx.lineTo(R+6,y); ctx.stroke();
        drawMathText(ctx,String(+v.toFixed(2)).replace(/\.00$/,""),R+8,y+4,{size:12,align:'left',color});
      } ctx.restore();
    }
    function drawBottomTicks(ctx, L, R, B, vals, mapX, color=AXIS_COLOR){
      ctx.save();
      ctx.strokeStyle = color;
      ctx.fillStyle   = color;
      ctx.lineWidth   = 1.5;
    
      for (const v of vals){
        const x = mapX(v);
        if (x < L-1 || x > R+1) continue;
        ctx.beginPath();
        ctx.moveTo(x, B);
        ctx.lineTo(x, B - 6);
        ctx.stroke();
        const s = (Math.abs(v) < 10 ? v.toFixed(2) : v.toFixed(1))
                   .replace(/\.00?$/,''); 
        drawMathText(ctx, s, x, B - 8, { size: 12, align: 'center', color });
      }
      ctx.restore();
    }

    // =================
    // Global sim state
    // =================
    let state={
      N:50,R:5,d0:0.5,epsilon:0.5,nfreq:0.5,dt:DT, stepsPerFrame:500, alphaRatio:0.5,
      alpha:0, alphaC:0, OmegaEq:0, t:0, theta:[], omega:[], colors:[], thetaVG:0,
      timeSeries:{t:[],meanOmega:[],meanFlux:[],omega1:[]},
      yMaxDelta:0, running:false, crashed:false,
      timeWindow:100  // NEW: default time window
    };

    // ==========================
    // Parameters & initialization
    // ==========================
    const computeAlphaC=(N,R,d0)=> 2*R*Math.exp(-(TWO_PI*R/N - d0));
    function updateOmegaEq(){
      const d = TWO_PI/state.N;
      state.OmegaEq = (state.R*d > state.d0)
        ? (1 - Math.exp(-(state.R*d - state.d0)))
        : 0;
      syncRefCheckbox();
    }

    function initArrays(){
      const {N,epsilon,nfreq}=state, d=TWO_PI/N;
      state.theta=new Array(N); state.omega=new Array(N);
      for(let i=0;i<N;i++){ state.theta[i]=i*d - epsilon*Math.sin(nfreq*i*d); state.omega[i]=state.OmegaEq; }
      state.colors=colormapHSV(N); state.thetaVG=0;
      state.timeSeries={t:[],meanOmega:[],meanFlux:[],omega1:[]};
      state.yMaxDelta=0; state.t=0;
    }

    function applyParams({restartIfNChanged=true}={}){
      const prevN=state.N;
      state.N=Math.max(3,Math.min(2000,parseInt(inpN.value||"50")));
      state.R=parseFloat(inpR.value||"5");
      state.d0=parseFloat(inpd0.value||"0.5");
      state.epsilon=parseFloat(inpEps.value||"0.5");
      state.nfreq=parseFloat(inpNfreq.value||"0.5");
      state.dt = DT;
      let spf=Math.round(+inpSteps.value); state.stepsPerFrame = (Number.isFinite(spf)&&spf>0)?spf:1;
      state.alphaRatio=parseFloat(inpAlphaRatio.value||"0.5");
      const twRaw = parseFloat(inpTimeWindow.value || "100");
      state.timeWindow = (Number.isFinite(twRaw) && twRaw > 0) ? twRaw : 100;  // NEW
      state.alphaC=computeAlphaC(state.N,state.R,state.d0);
      state.alpha=state.alphaRatio*state.alphaC;
      updateOmegaEq();
      if(restartIfNChanged && prevN!==state.N) initArrays();
    }

    function saveUIFromState(){
      inpN.value=state.N; inpR.value=state.R; inpd0.value=state.d0; inpEps.value=state.epsilon;
      inpNfreq.value=state.nfreq; inpSteps.value=state.stepsPerFrame; inpAlphaRatio.value=state.alphaRatio;
      if (inpTimeWindow) inpTimeWindow.value = state.timeWindow;
    }

    // =================
    // Core time update
    // =================
    function stepOnce(){
      const {N,R,d0,alpha,dt}=state;
      for(let i=0;i<N;i++){ state.theta[i]=wrapAngle(state.theta[i]+state.omega[i]*dt); }
      const dth = new Array(N);
      for (let i=0;i<N;i++){
        const raw = state.theta[(i+1)%N] - state.theta[i];
        let signed = raw;
        if (signed > Math.PI)  signed -= TWO_PI;
        if (signed <= -Math.PI) signed += TWO_PI;
        if (signed < -1e-12) state.crashed = true;
        const wrapped = raw < 0 ? raw + TWO_PI : raw;
        dth[i] = wrapped;
        if (wrapped <= EPS_CRASH) state.crashed = true;
      }
      for(let i=0;i<N;i++){
        const stop=(R*dth[i])<=d0;
        if(stop) state.omega[i]+=dt*(-alpha*state.omega[i]);
        else { const term=1-Math.exp(-(R*dth[i]-d0)); state.omega[i]+=dt*alpha*(term-state.omega[i]); }
        if(state.omega[i]<0 && state.omega[i]>-1e-12) state.omega[i]=0;
      }
      return dth;
    }

    function currentDeltaTheta(){
      const N=state.N,a=new Array(N);
      for(let i=0;i<N;i++){ let d=state.theta[(i+1)%N]-state.theta[i]; if(d<0) d+=TWO_PI; a[i]=d; }
      return a;
    }

    function computeFluxAndStats(dth){
      const N=state.N; let meanJ=0,sumSq=0;
      for(let i=0;i<N;i++){
        const prev=(i-1+N)%N; const denom=Math.max(0.5*(dth[i]+dth[prev]),1e-6);
        const J=state.omega[i]/denom; meanJ+=J;
        const d=(state.omega[i]-state.OmegaEq); sumSq+=d*d;
      }
      meanJ/=N; const rmsOmega=Math.sqrt(sumSq/N);
      let rhoH=0,rhoL=Infinity;
      for(const d of dth){ rhoH=Math.max(rhoH,1/d); rhoL=Math.min(rhoL,1/d); }
      const omegaL=Math.max(...state.omega);
      let vg=0; if(isFinite(rhoL)&&rhoH>0&&rhoL<rhoH) vg = omegaL*(rhoL/rhoH)/(1-(rhoL/rhoH));
      state.thetaVG=wrapAngle(state.thetaVG - vg*state.dt*state.stepsPerFrame);
      return {meanJ,rmsOmega};
    }

    // ============
    // Drawing API
    // ============
    function drawMain(dth){
      const {W,H}=prepCanvas(main,ctxMain);
      const baseR=Math.min(W*.38,H*.42); let pxOff=2.5*baseR;
      const maxOff=Math.max(0,W-baseR*2.2); if(pxOff>maxOff) pxOff=maxOff;
      const cxL=Math.min(W*.30,W/2 - pxOff/2), cy=H/2, cxR=cxL+pxOff;

      const drawCircle=(cx,cy,r,col="#2b3245")=>{ ctxMain.beginPath(); ctxMain.arc(cx,cy,r,0,TWO_PI); ctxMain.strokeStyle=col; ctxMain.lineWidth=1.3; ctxMain.stroke(); };
      const fillWedge=(cx,cy,r,a0,a1,col)=>{ ctxMain.beginPath(); ctxMain.moveTo(cx,cy); ctxMain.arc(cx,cy,r,a0,a1,false); ctxMain.closePath(); ctxMain.fillStyle=col; ctxMain.fill(); };

      const {r:r1,phi:phi1}=complexMeanAngles(state.theta);
      let rhoH=0,rhoL=Infinity; for(const d of dth){ rhoH=Math.max(rhoH,1/d); rhoL=Math.min(rhoL,1/d);} 
      let phi_l=0,phi_h=0; if(isFinite(rhoL)&&rhoH>rhoL){ phi_l=(TWO_PI*rhoH-state.N)/(rhoH-rhoL); phi_h=TWO_PI-phi_l; phi_l=clamp(phi_l,0,TWO_PI); phi_h=clamp(phi_h,0,TWO_PI);} 

      drawCircle(cxL,cy,baseR);
      if (showPhase()) {
        if(phi_h>0) fillWedge(cxL,cy,baseR,phi1-phi_h/2,phi1+phi_h/2,"rgba(220,70,70,0.32)");
        if(phi_l>0) fillWedge(cxL,cy,baseR,(phi1-Math.PI)-phi_l/2,(phi1-Math.PI)+phi_l/2,"rgba(70,190,100,0.32)");
      }

      if (showPhase()) {
        const rVG=baseR*1.1;
        ctxMain.beginPath(); ctxMain.arc(cxL+rVG*Math.cos(state.thetaVG), cy+rVG*Math.sin(state.thetaVG),4.5,0,TWO_PI); ctxMain.fillStyle="#8a93a8"; ctxMain.fill();
        ctxMain.beginPath(); ctxMain.arc(cxL+baseR*r1*Math.cos(phi1), cy+baseR*r1*Math.sin(phi1),5.5,0,TWO_PI); ctxMain.fillStyle="#53f79e"; ctxMain.fill();
      }

      for(let k=0;k<state.N;k++){
        const x=cxL+baseR*Math.cos(state.theta[k]), y=cy+baseR*Math.sin(state.theta[k]);
        ctxMain.beginPath(); ctxMain.arc(x,y,4.2*DOT_SCALE,0,TWO_PI); ctxMain.fillStyle=state.colors[k]; ctxMain.fill();
      }

      if(state.OmegaEq>0 && showRefRing() && pxOff>baseR*.2){
        drawCircle(cxR,cy,baseR);
        for(let k=0;k<state.N;k++){
          const x=cxR+baseR*Math.cos(state.theta[k]-state.OmegaEq*state.t), y=cy+baseR*Math.sin(state.theta[k]-state.OmegaEq*state.t);
          ctxMain.beginPath(); ctxMain.arc(x,y,4*DOT_SCALE,0,TWO_PI); ctxMain.fillStyle=state.colors[k]; ctxMain.fill();
        }
      }

      drawMathText(ctxMain,"θ_{i}(t)",cxL-8,cy-8,{size:FONT_PX,align:'left'});
      if(state.OmegaEq>0 && showRefRing() && pxOff>baseR*.2)
        drawMathText(ctxMain,"θ_{i}(t) − Ω_{eq} t",cxR-30,cy-8,{size:FONT_PX,align:'left'});
    }

    function drawAgentCharts(){
      const {W,H}=prepCanvas(cnvOmega,ctxOmega);
      const LEFT=72, RIGHT=W-16, TITLE_Y=20, TOP=TITLE_Y+25, BOTTOM=H-30;

      ctxOmega.strokeStyle=AXIS_COLOR; ctxOmega.lineWidth=AXIS_W;
      ctxOmega.beginPath();
      ctxOmega.moveTo(LEFT,BOTTOM); ctxOmega.lineTo(RIGHT,BOTTOM);
      ctxOmega.moveTo(LEFT,TOP);    ctxOmega.lineTo(LEFT,BOTTOM);
      ctxOmega.stroke();

      drawMathText(ctxOmega,`Ω_{eq} = ${state.OmegaEq.toFixed(4)}` ,W/2,TITLE_Y,{size:FONT_PX,align:'center'});
      ctxOmega.strokeStyle="#8a93a8"; ctxOmega.setLineDash([5,6]); ctxOmega.lineWidth=DASH_W;
      const yOeq=TOP+(1-(state.OmegaEq/1.05))*(BOTTOM-TOP);
      ctxOmega.beginPath(); ctxOmega.moveTo(LEFT,yOeq); ctxOmega.lineTo(RIGHT,yOeq); ctxOmega.stroke(); ctxOmega.setLineDash([]);

      ctxOmega.strokeStyle=AXIS_COLOR; ctxOmega.lineWidth=AXIS_W;
      { const yOne=TOP+(1-(1/1.05))*(BOTTOM-TOP); ctxOmega.beginPath(); ctxOmega.moveTo(LEFT,yOne); ctxOmega.lineTo(RIGHT,yOne); ctxOmega.stroke(); }

      const mapY=v=> TOP + (1-(v/1.05))*(BOTTOM-TOP);
      drawLeftTicks(ctxOmega,LEFT,TOP,BOTTOM,[0,.25,.5,.75,1],mapY,AXIS_COLOR);

      {
        const dth=currentDeltaTheta();
        const dMax=Math.max(...dth);
        const gap = Math.max(0, state.R*dMax - state.d0);
        const omegaSS = 1 - Math.exp(-gap);
        const ySS = TOP + (1 - (clamp(omegaSS,0,1.05)/1.05))*(BOTTOM - TOP);
        ctxOmega.strokeStyle="#60a5fa"; ctxOmega.setLineDash([6,6]); ctxOmega.lineWidth=DASH_W;
        ctxOmega.beginPath(); ctxOmega.moveTo(LEFT,ySS); ctxOmega.lineTo(RIGHT,ySS); ctxOmega.stroke(); ctxOmega.setLineDash([]);
      }

      ctxOmega.strokeStyle="#8892a6"; ctxOmega.lineWidth=2;
      ctxOmega.beginPath();
      for(let i=0;i<state.N;i++){
        const x=LEFT+((RIGHT-LEFT))*(i/(state.N-1));
        const y=TOP+(1-clamp(state.omega[i]/1.05,0,1))*(BOTTOM-TOP);
        if(i===0) ctxOmega.moveTo(x,y); else ctxOmega.lineTo(x,y);
      }
      ctxOmega.stroke();
      for(let i=0;i<state.N;i++){
        const x=LEFT+((RIGHT-LEFT))*(i/(state.N-1));
        const y=TOP+(1-clamp(state.omega[i]/1.05,0,1))*(BOTTOM-TOP);
        ctxOmega.beginPath(); ctxOmega.arc(x,y,3.2*DOT_SCALE,0,TWO_PI); ctxOmega.fillStyle=state.colors[i]; ctxOmega.fill();
      }

      drawMathText(ctxOmega,"Agent (i)",W/2,H-8,{size:FONT_PX,align:'center'});
      ctxOmega.save(); ctxOmega.translate(14,H/2); ctxOmega.rotate(-Math.PI/2);
      drawMathText(ctxOmega,"ω_{i} / Ω_{max}",0,0,{size:FONT_PX,align:'center'}); ctxOmega.restore();
    }

    function drawDeltaChart(dth){
      const {W,H}=prepCanvas(cnvDelta,ctxDelta);
      const LEFT=72, RIGHT=W-16, TITLE_Y=20, TOP=TITLE_Y+25, BOTTOM=H-30;
      const deltaVal = TWO_PI / state.N;
      drawMathText(ctxDelta, `Δ^{*} = 2π/N = ${deltaVal.toFixed(4)}`, W/2, TITLE_Y, { size: FONT_PX, align: "center" });

      ctxDelta.strokeStyle=AXIS_COLOR; ctxDelta.lineWidth=AXIS_W;
      ctxDelta.beginPath();
      ctxDelta.moveTo(LEFT,BOTTOM); ctxDelta.lineTo(RIGHT,BOTTOM);
      ctxDelta.moveTo(LEFT,TOP);    ctxDelta.lineTo(LEFT,BOTTOM);
      ctxDelta.stroke();

      const d0ang=state.d0/state.R, delta=TWO_PI/state.N;
      state.yMaxDelta=Math.max(state.yMaxDelta, Math.ceil(Math.max(...dth)/0.1)*0.1);
      const rangeH = BOTTOM - TOP;
      const posMax = Math.max(1e-9, state.yMaxDelta);
      const negPad = 0.05 * posMax;
      const yFrom  = v => TOP + (1 - ((v + negPad) / (posMax + negPad))) * rangeH;

      ctxDelta.setLineDash([6,6]);
      ctxDelta.lineWidth = DASH_W;
      
      ctxDelta.strokeStyle = "#cc6666";
      ctxDelta.beginPath();
      ctxDelta.moveTo(LEFT, yFrom(d0ang));
      ctxDelta.lineTo(RIGHT, yFrom(d0ang));
      ctxDelta.stroke();
      
      ctxDelta.strokeStyle = "#bbbbbb";
      ctxDelta.beginPath();
      ctxDelta.moveTo(LEFT, yFrom(delta));
      ctxDelta.lineTo(RIGHT, yFrom(delta));
      ctxDelta.stroke();
      
      ctxDelta.strokeStyle = "#ffffff";
      ctxDelta.beginPath();
      ctxDelta.moveTo(LEFT, yFrom(0));
      ctxDelta.lineTo(RIGHT, yFrom(0));
      ctxDelta.stroke();
      
      ctxDelta.setLineDash([]);

      { const step=.1, maxTick=Math.max(step, Math.ceil(state.yMaxDelta/step)*step); const vals=[]; for(let v=0; v<=maxTick+1e-12; v+=step) vals.push(+v.toFixed(2)); drawLeftTicks(ctxDelta,LEFT,TOP,BOTTOM,vals,yFrom,AXIS_COLOR); }

      const yD0=yFrom(d0ang), yDelta=yFrom(delta);
      const labelPad = 6;
      let yD0Label = yD0 + (FONT_PX + labelPad);
      if (yD0Label > BOTTOM - 8) yD0Label = yD0 - 8;
      drawMathText(ctxDelta,"d_{0}/R",LEFT+14, yD0Label, {size:FONT_PX,align:'left',color:'#cc6666'});
      drawMathText(ctxDelta,"2π/N",RIGHT-4,yDelta-6,{size:FONT_PX,align:'right',color:'#bbbbbb'});

      ctxDelta.strokeStyle="#7d8ecb"; ctxDelta.lineWidth=2; ctxDelta.beginPath();
      for(let i=0;i<state.N;i++){ const x=LEFT+((RIGHT-LEFT))*(i/(state.N-1)); const y=yFrom(dth[i]); if(i===0) ctxDelta.moveTo(x,y); else ctxDelta.lineTo(x,y);} ctxDelta.stroke();
      for(let i=0;i<state.N;i++){ const x=LEFT+((RIGHT-LEFT))*(i/(state.N-1)); const y=yFrom(dth[i]); ctxDelta.beginPath(); ctxDelta.arc(x,y,3*DOT_SCALE,0,TWO_PI); ctxDelta.fillStyle=dth[i]>0?state.colors[i]:"#222"; ctxDelta.fill(); }

      drawMathText(ctxDelta,"Agent (i)",W/2,H-8,{size:FONT_PX,align:'center'});
      ctxDelta.save(); ctxDelta.translate(14,H/2); ctxDelta.rotate(-Math.PI/2); drawMathText(ctxDelta,"Δ_{i} (rad)",0,0,{size:FONT_PX,align:'center'}); ctxDelta.restore();
    
      if (state.crashed) {
        ctxDelta.save();
        ctxDelta.globalAlpha = 0.95;
        ctxDelta.fillStyle = "rgba(251,113,133,0.95)";
        ctxDelta.strokeStyle = "rgba(0,0,0,0.7)";
        ctxDelta.lineWidth = 6;

        const msg = "Crashed Detected";
        const fontPx = Math.min(64, Math.max(28, Math.floor(H*0.18)));
        ctxDelta.font = `${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Ubuntu`;
        ctxDelta.textAlign = "center";
        ctxDelta.textBaseline = "middle";

        const centerY = (TOP + BOTTOM) / 2;
        ctxDelta.strokeText(msg, W/2, centerY);
        ctxDelta.fillText(msg, W/2, centerY);
        ctxDelta.restore();
      }
    }

    function drawTimeSeries(){
      cnvTime.style.display='block'; const tArr=state.timeSeries.t; if(tArr.length<2) { const _=prepCanvas(cnvTime,ctxTime); return; }
      const {W,H}=prepCanvas(cnvTime,ctxTime); const LEFT=72, RIGHT=W-72, TOP=10, BOTTOM=H-30; ctxTime.strokeStyle=AXIS_COLOR; ctxTime.lineWidth=AXIS_W; ctxTime.beginPath(); ctxTime.moveTo(LEFT,BOTTOM); ctxTime.lineTo(RIGHT,BOTTOM); ctxTime.moveTo(LEFT,TOP); ctxTime.lineTo(LEFT,BOTTOM); ctxTime.moveTo(RIGHT,TOP); ctxTime.lineTo(RIGHT,BOTTOM); ctxTime.stroke();
      const tmin=tArr[0], tmax=tArr[tArr.length-1], mapX=v=> LEFT + ((v-tmin)/(tmax-tmin))*(RIGHT-LEFT);
      const xTicks = niceTicks(tmin, tmax, 6);
      drawBottomTicks(ctxTime, LEFT, RIGHT, BOTTOM, xTicks, mapX, AXIS_COLOR);
      const L=state.timeSeries.meanOmega, R=state.timeSeries.meanFlux, d=TWO_PI/state.N; const Jss=(state.R*d>state.d0)? (1-Math.exp(-(state.R*d-state.d0)))*(state.N/(TWO_PI)) : undefined;
      let lmin=Math.min(...L), lmax=Math.max(...L); if(!isFinite(lmin)||!isFinite(lmax)){ lmin=0; lmax=1; } const lpad=(lmax-lmin||1)*.15; const mapY1=v=> TOP + (1-((v-(lmin-lpad))/((lmax+lpad)-(lmin-lpad))))*(H-40);
      let rmin=Math.min(...R), rmax=Math.max(...R); if(Number.isFinite(Jss)){ rmin=Math.min(rmin,Jss); rmax=Math.max(rmax,Jss);} if(!isFinite(rmin)||!isFinite(rmax)){ rmin=0; rmax=1; } const rpad=(rmax-rmin||1)*.15; const mapY2=v=> TOP + (1-((v-(rmin-rpad))/((rmax+rpad)-(rmin-rpad))))*(H-40);
      drawLeftTicks(ctxTime,LEFT,TOP,BOTTOM,niceTicks(lmin-lpad,lmax+lpad,5),mapY1,AXIS_COLOR);
      drawRightTicks(ctxTime,RIGHT,TOP,BOTTOM,niceTicks(rmin-rpad,rmax+rpad,5),mapY2,"#f5a14b");
      ctxTime.strokeStyle="#6bb7ff"; ctxTime.lineWidth=2; ctxTime.beginPath(); for(let i=0;i<L.length;i++){ const x=mapX(tArr[i]), y=mapY1(L[i]); if(i===0) ctxTime.moveTo(x,y); else ctxTime.lineTo(x,y);} ctxTime.stroke();
      ctxTime.strokeStyle="#f5a14b"; ctxTime.lineWidth=2; ctxTime.beginPath(); for(let i=0;i<R.length;i++){ const x=mapX(tArr[i]), y=mapY2(R[i]); if(i===0) ctxTime.moveTo(x,y); else ctxTime.lineTo(x,y);} ctxTime.stroke();
      if(Number.isFinite(Jss)){ ctxTime.setLineDash([6,6]); ctxTime.lineWidth=DASH_W; ctxTime.strokeStyle="#f5a14b"; const yRef=mapY2(Jss); ctxTime.beginPath(); ctxTime.moveTo(LEFT,yRef); ctxTime.lineTo(RIGHT,yRef); ctxTime.stroke(); ctxTime.setLineDash([]); }
      drawMathText(ctxTime,"t (Ω_{max}^{-1})",W/2,H-8,{size:FONT_PX,align:'center'});
      ctxTime.save(); ctxTime.translate(14,H/2); ctxTime.rotate(-Math.PI/2); drawMathText(ctxTime, state.OmegaEq>0?"RMS(ω−Ω_{eq})/Ω_{eq}":"RMS(ω−Ω_{eq})",0,0,{size:FONT_PX,align:'center'}); ctxTime.restore();
      const rightTickStrings = niceTicks(rmin-rpad,rmax+rpad,5).map(v=>String(+v.toFixed(2)).replace(/\.00$/,""));
      ctxTime.font = `${12}px system-ui, -apple-system, Segoe UI, Roboto`;
      let maxRightW = 0; for(const s of rightTickStrings){ const w = ctxTime.measureText(s).width; if(w>maxRightW) maxRightW = w; }
      const labelX = RIGHT + 8 + maxRightW + 24;
      ctxTime.save(); ctxTime.translate(labelX,H/2); ctxTime.rotate(-Math.PI/2);
      drawMathText(ctxTime,"⟨J⟩",0,0,{size:FONT_PX,align:'center',color:'#f5a14b'});
      ctxTime.restore();
    }

    // NEW: angular speed of Agent #1 vs time with moving window
    function drawOmega1Series(){
      const tArr = state.timeSeries.t;
      const yArr = state.timeSeries.omega1;
      const {W,H} = prepCanvas(cnvOmega1, ctxOmega1);
      if (tArr.length < 2 || yArr.length < 2) return;

      const LEFT = 72, RIGHT = W - 16, TOP = 10, BOTTOM = H - 30;

      const tmax = tArr[tArr.length - 1];
      const windowWidth = state.timeWindow || 100;
      const rawTmin = tArr[0];
      const tmin = Math.max(rawTmin, tmax - windowWidth);

      // Filter indices in the active window
      const idx = [];
      for (let i = 0; i < tArr.length; i++) {
        if (tArr[i] >= tmin - 1e-12) idx.push(i);
      }
      if (idx.length < 2) return;

      const mapX = v => LEFT + ((v - tmin) / (tmax - tmin || 1)) * (RIGHT - LEFT);

      // Axes
      ctxOmega1.strokeStyle = AXIS_COLOR;
      ctxOmega1.lineWidth   = AXIS_W;
      ctxOmega1.beginPath();
      ctxOmega1.moveTo(LEFT, BOTTOM);
      ctxOmega1.lineTo(RIGHT, BOTTOM);
      ctxOmega1.moveTo(LEFT, TOP);
      ctxOmega1.lineTo(LEFT, BOTTOM);
      ctxOmega1.stroke();

      const xTicks = niceTicks(tmin, tmax, 6);
      drawBottomTicks(ctxOmega1, LEFT, RIGHT, BOTTOM, xTicks, mapX, AXIS_COLOR);

      // Y range based on window
      let ymin = Infinity, ymax = -Infinity;
      for (const k of idx) {
        const v = yArr[k];
        if (!Number.isFinite(v)) continue;
        if (v < ymin) ymin = v;
        if (v > ymax) ymax = v;
      }
      if (!isFinite(ymin) || !isFinite(ymax)) {
        ymin = 0; ymax = 1;
      }
      ymin = Math.min(0, ymin);
      ymax = Math.max(1, ymax * 1.05);
      const pad = (ymax - ymin || 1) * 0.1;
      const yLo = ymin - pad;
      const yHi = ymax + pad;
      const mapY = v => TOP + (1 - ((v - yLo) / (yHi - yLo || 1))) * (BOTTOM - TOP);

      const yTicks = niceTicks(yLo, yHi, 5);
      drawLeftTicks(ctxOmega1, LEFT, TOP, BOTTOM, yTicks, mapY, AXIS_COLOR);

      // Agent #1 angular speed curve (light blue, medium width)
      ctxOmega1.strokeStyle = "#6ee7ff";
      ctxOmega1.lineWidth   = 2;
      ctxOmega1.beginPath();
      let first = true;
      for (const k of idx){
        const x = mapX(tArr[k]);
        const y = mapY(yArr[k]);
        if (first) { ctxOmega1.moveTo(x,y); first=false; }
        else ctxOmega1.lineTo(x,y);
      }
      ctxOmega1.stroke();

      // Axis labels
      drawMathText(ctxOmega1, "Time (1/Ω_{max})", W/2, H-8, { size: FONT_PX, align: 'center' });
      ctxOmega1.save();
      ctxOmega1.translate(14, H/2);
      ctxOmega1.rotate(-Math.PI/2);
      drawMathText(ctxOmega1, "Angular Speed (\\dot{θ}/Ω_{max})", 0, 0, { size: FONT_PX, align: 'center' });
      ctxOmega1.restore();
    }

    // =========
    // Main loop
    // =========
    function tick(){
      if(!state.running) return;
      let dth;
      for (let s=0; s<state.stepsPerFrame; s++){
        dth = stepOnce();
        state.t += state.dt;
        if (state.crashed) { state.running = false; break; }
      }
      const {meanJ,rmsOmega}=computeFluxAndStats(dth);

      state.timeSeries.t.push(state.t);
      state.timeSeries.meanOmega.push(state.OmegaEq>0? rmsOmega/state.OmegaEq : rmsOmega);
      state.timeSeries.meanFlux.push(meanJ);
      state.timeSeries.omega1.push(state.omega[0]); // agent #1 angular speed

      titlePolar.innerHTML='T (Ω<sub>max</sub><sup>-1</sup>) = '+state.t.toFixed(1);
      drawMain(dth); 
      drawAgentCharts(); 
      drawDeltaChart(dth); 
      drawTimeSeries();
      drawOmega1Series();

      if (!state.running) updateButtons();
      if (state.running && !state.crashed) rafId = requestAnimationFrame(tick);
    }

    function stepFrame(){
      if (state.running) return;
    
      let dth;
      for (let s=0; s<state.stepsPerFrame; s++){
        dth = stepOnce();
        state.t += state.dt;
        if (state.crashed) break;
      }
    
      if (typeof updateKymos === 'function') updateKymos(dth);
    
      const {meanJ, rmsOmega} = computeFluxAndStats(dth);
      state.timeSeries.t.push(state.t);
      state.timeSeries.meanOmega.push(state.OmegaEq>0 ? rmsOmega/state.OmegaEq : rmsOmega);
      state.timeSeries.meanFlux.push(meanJ);
      state.timeSeries.omega1.push(state.omega[0]); // agent #1 angular speed

      titlePolar.innerHTML = 'T (Ω<sub>max</sub><sup>-1</sup>) = ' + state.t.toFixed(1);
      drawMain(dth);
      drawAgentCharts();
      drawDeltaChart(dth);
      if (typeof drawKymoPanels === 'function') drawKymoPanels();
      drawTimeSeries();
      drawOmega1Series();
    }
    
    // =====
    // Reset
    // =====
    function hardReset({apply=true}={}){
      const was=state.running; state.running=false;
      if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; }
      if(apply) applyParams({restartIfNChanged:true}); else updateOmegaEq();
      state.crashed = false;
      forceInitialCheckboxes();
      initArrays();
      state.timeSeries={t:[],meanOmega:[],meanFlux:[],omega1:[]}; 
      titlePolar.innerHTML='T (Ω<sub>max</sub><sup>-1</sup>) = 0.0';
      const d=new Array(state.N).fill(TWO_PI/state.N);
      drawMain(d); 
      drawAgentCharts(); 
      drawDeltaChart(d); 
      drawTimeSeries();
      drawOmega1Series();
      if(was){ state.running=true; rafId = requestAnimationFrame(tick); }
      updateButtons();
    }

    function forceInitialCheckboxes(){
      if (chkPhase) chkPhase.checked = true;
      if (chkShowRef) {
        const allow = state.OmegaEq > 0;
        chkShowRef.disabled = !allow;
        chkShowRef.checked  = allow;
      }
    }

    // ==================
    // Drag / resize cards
    // ==================
    function initDragResize(){
      let dragEl=null;
      wrap.addEventListener('dragstart', e=>{
        const card=e.target.closest('.card'); if(!card) return;
        dragEl=card; card.classList.add('dragging');
        try{ e.dataTransfer.effectAllowed='move'; e.dataTransfer.setData('text/plain',''); }catch(_){} });
      wrap.addEventListener('dragend', ()=>{
        if(dragEl){ dragEl.classList.remove('dragging'); dragEl=null; syncCanvasSizes(); resizeAll(); }
      });
      wrap.addEventListener('dragover', e=>{
        e.preventDefault(); try{ e.dataTransfer.dropEffect='move'; }catch(_){ }
        const after=getDragAfterElement(wrap,e.clientX,e.clientY);
        const dragging=wrap.querySelector('.dragging'); if(!dragging) return;
        if(after==null) wrap.appendChild(dragging); else wrap.insertBefore(dragging,after);
      });
      wrap.addEventListener('dragenter', e=>{ e.preventDefault(); try{ e.dataTransfer.dropEffect='move'; }catch(_){ } });
      wrap.addEventListener('drop', e=>{
        e.preventDefault();
        const dragging=wrap.querySelector('.dragging'); if(!dragging) return;
        const after=getDragAfterElement(wrap,e.clientX,e.clientY);
        if(after==null) wrap.appendChild(dragging); else wrap.insertBefore(dragging,after);
      });
      function getDragAfterElement(container,x,y){
        const els=[...container.querySelectorAll('.card:not(.dragging)')];
        let closest={offset:-Infinity,element:null};
        for(const el of els){
          const r=el.getBoundingClientRect(); const off=y-r.top-r.height/2;
          if(off<0 && off>closest.offset) closest={offset:off,element:el};
        }
        return closest.element;
      }

      let resizing=null,startY=0,startH=0;
      wrap.addEventListener('mousedown', e=>{
        const handle=e.target.closest('.resizer'); if(!handle) return;
        resizing=handle.closest('.card'); const rect=resizing.getBoundingClientRect();
        startY=e.clientY; startH=rect.height; document.body.style.userSelect='none';
      });
      window.addEventListener('mousemove', e=>{
        if(!resizing) return;
        const dy=e.clientY-startY; resizing.style.height=Math.max(160,startH+dy)+'px';
        syncCanvasSizes(); resizeAll();
      });
      window.addEventListener('mouseup', ()=>{ if(resizing){ resizing=null; document.body.style.userSelect=''; } });
    }

    // =============================
    // Hover blurbs
    // =============================
    const HOVER_DELAY_MS = 2000;
    const hoverTimers = new WeakMap();
    
    function setupInfoBlurbs(){
      wrap.querySelectorAll('.card').forEach(card=>{
        const clear = ()=>{
          const t = hoverTimers.get(card);
          if (t){ clearTimeout(t); hoverTimers.delete(card); }
          hideBlurb(card);
        };
        card.addEventListener('mouseenter', ()=>{
          const t = setTimeout(()=> showBlurb(card), HOVER_DELAY_MS);
          hoverTimers.set(card, t);
        });
        card.addEventListener('mouseleave', clear);
        card.addEventListener('dragstart', clear);
      });
    }
    
    function showBlurb(card){
      let el = card.querySelector('.hoverBlurb');
      if (!el){
        el = document.createElement('div');
        el.className = 'hoverBlurb';
        el.textContent = card.dataset.blurb || 'Plot info';
        card.appendChild(el);
        requestAnimationFrame(()=> el.classList.add('show'));
      } else {
        el.classList.add('show');
      }
    }
    
    function hideBlurb(card){
      const el = card.querySelector('.hoverBlurb');
      if (el) el.classList.remove('show');
    }

    // =============================
    // Info icon tooltip support
    // =============================
    function initInfoIcons(){
      document.addEventListener('click', (e)=>{
        const icon = e.target.closest('.infoIcon');
        if (!icon){
          document.querySelectorAll('.infoIcon[data-open="1"]').forEach(el=>el.removeAttribute('data-open'));
          return;
        }
        const isOpen = icon.getAttribute('data-open') === '1';
        document.querySelectorAll('.infoIcon[data-open="1"]').forEach(el=>{ if(el!==icon) el.removeAttribute('data-open'); });
        if (isOpen) icon.removeAttribute('data-open'); else icon.setAttribute('data-open','1');
        e.stopPropagation();
      });
    
      document.addEventListener('keydown', (e)=>{
        if (e.key === 'Escape'){
          document.querySelectorAll('.infoIcon[data-open="1"]').forEach(el=>el.removeAttribute('data-open'));
        }
      });
    }

    // ======================
    // Events & first render
    // ======================
    function updateButtons(){
      if (btnStep) btnStep.disabled = !!state.running;
    }
    
    function resizeAll(){
      syncCanvasSizes();
      const d=currentDeltaTheta();
      drawMain(d); 
      drawAgentCharts(); 
      drawDeltaChart(d); 
      drawTimeSeries();
      drawOmega1Series();
    }
    
    inpSteps.addEventListener('input', ()=>{ let v=Math.round(+inpSteps.value); if(!Number.isFinite(v)||v<1) v=1; inpSteps.value=String(v); state.stepsPerFrame=v; });
    if (inpTimeWindow) {
      inpTimeWindow.addEventListener('input', () => {
        const val = parseFloat(inpTimeWindow.value || "100");
        state.timeWindow = (Number.isFinite(val) && val > 0) ? val : 100;
        drawOmega1Series();
      });
    }

    btnStart && btnStart.addEventListener('click', ()=>{ if(!state.running){ state.running=true; updateButtons(); rafId = requestAnimationFrame(tick); } });
    btnStop  && btnStop.addEventListener('click', ()=>{ state.running=false; if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; }; updateButtons(); });
    btnStep && btnStep.addEventListener('click', stepFrame);
    btnReset && btnReset.addEventListener('click', ()=> hardReset({apply:true}) );
    btnShare && btnShare.addEventListener('click', async () => {
      const url = new URL(location.href);
      url.search = buildShareQuery();
      try {
        await (navigator.clipboard && navigator.clipboard.writeText(url.toString()));
        alert('Shareable link copied to clipboard!');
      } catch (_) {
        prompt('Copy this link:', url.toString());
      }
    });
    chkShowRef && chkShowRef.addEventListener('change', resizeAll);
    chkPhase  && chkPhase.addEventListener('change', resizeAll);

    document.getElementById('howHost')?.addEventListener('click', e=>{
      e.preventDefault();
      alert(`Quick hosting (free):

1) Create a new public GitHub repo (e.g., traffic-model-web).
2) Add this single file as index.html and commit.
3) In repo Settings → Pages, pick “Deploy from a branch”, branch: main, folder: / (root).
4) Your app will be live at: https://<your-user>.github.io/traffic-model-web/

Netlify/Vercel: drag-and-drop this file into a new site. No build steps needed.`);
    });

    if (location.search && location.search.length > 1) {
      const ok = applyFromQuery(location.search);
      if (!ok) {
        applyParams({restartIfNChanged:false});
        forceInitialCheckboxes();
        initArrays();
        saveUIFromState();
        resizeAll();
      }
    } else {
      applyParams({restartIfNChanged:false});
      forceInitialCheckboxes();
      initArrays();
      saveUIFromState();
      resizeAll();
    }
  
    initDragResize();
    setupInfoBlurbs();
    initInfoIcons();
    updateButtons();
    if (selPreset) selPreset.value = '';
    window.addEventListener('resize', resizeAll);

    // Self-checks (unchanged except they still work with new plot)
    (function(){
      const tests=[], push=(n,ok,info="")=>tests.push({name:n,ok,info});
      try{
        const ac=computeAlphaC(50,5,0.6); push("alpha_c positive",ac>0,`alpha_c=${ac.toFixed(4)}`);
        const pN=state.N,pR=state.R,pd0=state.d0; state.N=50; state.R=5; state.d0=0.5; updateOmegaEq();
        push("OmegaEq zero in jammed limit", state.OmegaEq===0, `OmegaEq=${state.OmegaEq}`);
        state.N=pN; state.R=pR; state.d0=pd0; updateOmegaEq();

        const r1=parseMathRuns('Ω_{eq}'); push('parse subscript group', r1.length>=2 && r1[1].kind==='sub' && r1[1].text==='eq');
        const r2=parseMathRuns('ω_i');    push('parse single-char subscript', r2.length===2 && r2[1].kind==='sub' && r2[1].text==='i');
        const r3=parseMathRuns('Ω_{max}^{-1}'); push('parse sub & sup', r3.some(r=>r.kind==='sub') && r3.some(r=>r.kind==='sup'));

        const old=state.stepsPerFrame; inpSteps.value=300; applyParams({restartIfNChanged:false});
        push('stepsPerFrame updates', state.stepsPerFrame===300, `spf=${state.stepsPerFrame}`);
        inpSteps.value=old; applyParams({restartIfNChanged:false});

        push('drawMain defined', typeof drawMain==='function');
        push('drawDeltaChart defined', typeof drawDeltaChart==='function');
        push('drawTimeSeries defined', typeof drawTimeSeries==='function');
        push('drawOmega1Series defined', typeof drawOmega1Series==='function');
        push('initDragResize defined', typeof initDragResize==='function');
        push('niceTicks defined', typeof niceTicks==='function');

        push('buttons present', !!btnStart && !!btnStop && !!btnReset, `start=${!!btnStart}, stop=${!!btnStop}, reset=${!!btnReset}`);
        const cd=currentDeltaTheta(); push('deltaTheta length=N', cd.length===state.N, `len=${cd.length}`);
        try{ resizeAll(); push('resizeAll executes', true);}catch(err){ push('resizeAll executes', false, err&&err.message?err.message:String(err)); }

        push('constants defined', typeof AXIS_COLOR==='string' && typeof AXIS_W==='number' && typeof DASH_W==='number' && typeof FONT_PX==='number');
        push('DOT_SCALE set', Math.abs(DOT_SCALE-1.3)<1e-9, `DOT_SCALE=${DOT_SCALE}`);
        push('chkShowRef exists', !!document.getElementById('chkShowRef'));
        push('chkPhase exists', !!document.getElementById('chkPhase'));
        push('timeWindow default', state.timeWindow === 100, `timeWindow=${state.timeWindow}`);
      }catch(e){ push('self-test error',false,e&&e.message?e.message:String(e)); }
      console.table(tests);
    })();

    // Autostart
    state.running=false; rafId = requestAnimationFrame(tick);

  </script>
</body>
</html>
